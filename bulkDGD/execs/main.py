#!/usr/bin/env python
# -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-

#    main.py
#
#    Main command.
#
#    Copyright (C) 2024 Valentina Sora 
#                       <sora.valentina1@gmail.com>
#
#    This program is free software: you can redistribute it and/or
#    modify it under the terms of the GNU General Public License as
#    published by the Free Software Foundation, either version 3 of
#    the License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public
#    License along with this program. 
#    If not, see <http://www.gnu.org/licenses/>.


#######################################################################


# Set the module's description.
__doc__ = "Main command."


#######################################################################


# Import from the standard library.
import logging as log
# Import from 'bulkDGD'.
from . import (
    parsers,
    util)


#######################################################################


# Get the module's logger.
logger = log.getLogger(__name__)


#######################################################################

def main():

    # Set the main parser.
    parser = parsers.set_main_parser(description = __doc__)

    #-----------------------------------------------------------------#

    # Parse the arguments.
    args = parser.parse_args()

    #-----------------------------------------------------------------#

    # Get the 'work_dir' argument.
    wd = getattr(args, "work_dir", None)

    # Get the 'n_proc' argument.
    n_proc = getattr(args, "n_proc", None)

    #-----------------------------------------------------------------#

    # Set the logging.
    util.set_main_logging(args = args)

    #-----------------------------------------------------------------#

    # If the execution should be parallelized
    if args.parallelize:

        # Create a list to store the futures.
        futures = []

        #-------------------------------------------------------------#

        # Set the 'log_console' argument to False so that the logging
        # messages generated by the command launched are not printed to
        # the console.
        args.log_console = False

        #-------------------------------------------------------------#

        # Get the argument corresponding to the directories.
        work_dirs = \
            util.get_dirs(dir_names = args.dirs,
                          wd = wd)

        #-------------------------------------------------------------#

        # Import from 'distributed'.
        from distributed import LocalCluster, Client, as_completed

        # Create the local cluster.
        cluster = \
            LocalCluster(# Number of workers
                         n_workers = n_proc,
                         # Below which level log messages will
                         # be silenced
                         silence_logs = "ERROR",
                         # Whether to use processes, single-core
                         # or threads
                         processes = True,
                         # How many threads for each worker
                         # should be used
                         threads_per_worker = 1)

        # Open the client from the cluster.
        client = Client(cluster)

        #-------------------------------------------------------------#

        # For each working directory
        for work_dir in work_dirs:

            # Set the arguments.
            arguments = util.set_executable_args(args = args,
                                                 wd = work_dir,
                                                 main_wd = wd)

            # Inform the user that we are submitting the calculation.
            infostr = \
                f"Submitting the calculation in '{work_dir}' " \
                "directory. Command line: " \
                f"{' '.join(arguments)}."
            logger.info(infostr)

            # Submit the calculation.
            futures.append(\
                client.submit(\
                    util.run_executable,
                    executable = "_bulkdgd_exec",
                    arguments = arguments,
                    extra_return_values = [work_dir]))
        
        #-------------------------------------------------------------#

        # Get the futures as they are completed.
        for _, result in as_completed(futures,
                                      with_results = True):

            # Get the process and the working directory.
            process, work_dir = result

            # Check the process' return code.
            try:

                process.check_returncode()

            # If something went wrong
            except Exception:

                # Log the error.
                errstr = \
                    f"The run in the '{work_dir}' directory failed. " \
                    "Please check the log file in the directory for " \
                    "more information."
                logger.error(errstr)

                # Go to the next future.
                continue

            # Inform the user that the run completed successfully.
            infostr = \
                f"The run in the directory '{work_dir}' completed " \
                "successfully."
            logger.info(infostr)
    
    #-----------------------------------------------------------------#

    # Otherwise
    else:

        # Set the arguments.
        arguments = util.set_executable_args(args = args,
                                             wd = wd,
                                             main_wd = wd)

        # Run the executable.
        util.run_executable(\
            executable = "_bulkdgd_exec",
            arguments = arguments)
        